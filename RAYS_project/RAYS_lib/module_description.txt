
Description of module: axisym_toroid_eq_m

A general toroidal equilibrium module that supports a choice of magnetics, density,
and temperature models.  It is assumed that there exists a poloidal flux function
on which the densities and temperatures are constant. An external magnetics module is
required for each magnetics model which provides B, grad B tensor, and the flux function,
psi, along with it's gradient (poloidal_flux_model).  The magnetics model also provides
certain geometry data on initialization.

Input to axisym_toroid_eq() is rvec = (x,y,z) position
Outputs from axisym_toroid_eq() are all quantities needed to fill an eq_point type

Presently supported magnetics models are: 'solovev_magnetics', 'eqdsk_magnetics_lin_interp'
and 'eqdsk_magnetics_spline_interp'

Presently supported density models: 'constant', 'parabolic', 'density_spline_interp'
All species presently use the same density profile model.  Otherwise charge neutrality is
complicated.

Presently supported temperature models: 'zero' 'constant', 'parabolic',
and 'temperature_spline_interp'
Different species can have different profile models. Although presently only two different
spline profiles are supported: electron and ion.  All splined ion profiles are the same.

Convenience routines are also provided:
axisym_toroid_psi(rvec, psi, gradpsi, psiN, grad_psiN) returns psi and PsiN == nomalized
poloidal flux and gradients

axisym_toroid_rho(rvec, rho, gradrho) returns rho == sqrt(toroidal flux) and gradient
So far this is only implemented for the eqdsk_magnetics_spline_interp model

write_axisym_toroid_profiles writes the radial profile of the equilibirum quantities to
either the message unit or to stdout

External procedures: Only from modules used.

Description of module: axisym_toroid_ray_init_R_Z_nphi_ntheta_m

Parameters to generate the initial conditions for the rays
i.e. intitial position for each ray: rvec0(1:3, iray) and
information necessary to initialize k for each ray: kvec0(1:3, iray)
This routine initializes based on initial launch position (R,Z) and initial
refractive indices in the toroidal and poloidal directions (n_phi, n_theta)
For now there is only one launch position (trivial to generalize)
Note: initialization of k requires solution of the dispersion relation
and depends on magnetic field and density information.  The actual
initialization of k occurs in subroutine 'initialize' which is called from
subroutine 'ray_tracing'.   Here the information necessary to do this
calculation (e.g. toroidal, poloidal mode number, toroidal, poloidal wave
number) is generated from data on the number of launch angles etc. and put
into rvec0, kvec0.  The values for rvec0, kvec0 are generated in the module
routines 'ray_init_...'
There are several reasonable ways to initialize k values,
particularly in toroidal geometry.  At low frequencies toroidal and poloidal mode
numbers are meaningful.  At higher frequencies the launch angle is more useful.
For ECH one launches a beam with a distribution of rays around a central beam axis.
The variable ray_init_model determines which of several k intialization schemes are used

Description of module: constants_m

contains useful contants. Note that units are MKS.

Description of module: damping_m

Contains parameters and routines to calculate damping

Description of module: density_spline_interp_m

Implements density profiles based on pointwise data contained in makelist
density_spline_interp_list.
At present (8/12/2024) this only produces only one profile (presumably electrons),
normalized to one.  This is similar to the "parabolic" profiles implemented in the
body of axisym_toroid_eq_m. The ion species then track the electron density with
fraction of the electron density given by n0s(0:nspec).  In the future, when ion dynamics
counts (e.g. ICRF) and separate ion density data is provided, something more elaborate
will be necessary.  In particular how to ensure charge neutrality and specify Zeff.
The density values in the namelist are assumed to be on a uniform grid from 0.0 to 1.0
For psi > 1.0 returns dens = d_scrape_off, dd_psi = 0.

For now only one spline_density_model and one function is exported, spline_density_ne.
So, for now, namelist variable 'spline_density_model' is not used.


Description of module: diagnostics_m

Controls output to files, stdio, etc

Contains and initializes fortran output unit numbers.
Contains diagnostic switches, error flags, and other miscellaneous data
Provides two generic routines (message and text_message) to produce formatted output
requiring only one line of code.
A switch -> 'verbosity' gives central control of how much output is produced.
messages are suppressed unless the optional argument 'threshold' is >= 'verbosity'.
Routines are also provided to toggle 'message_unit' the originally specified
unit number over to a diffferent unit and back so messages could be sent to other files
'set_message_unit_stdio' and 'reset_message_unit_file'
External procedures: cpu_time (intrinsic)

Description of module: dispersion_solvers_m

Contains routines to solve various forms of the plasma dispersion relation

The particular model to be solved is specified by argument "dispersion_model"
Presently one model is supported: cold, (warm real soon now)

Presently two forms for this model are supported:
1) solve_n1_vs_n2_n3
n1 = component of nvec perpendicular to B to be solved for (e.g. x or radial component)
n2 = transverse component of nvec i.e. perpendicular to both B and n1
n3 = parallel component of kvec (nvec)

2) solve_n_vs_theta
n = scalar refractive index
theta = angle between vector refractive index and B
This is essentially Appleton_Hartree

The user also specifies which mode to select (wave_mode).
Cold plasma presents 4 possibilites -> plus/minus in solution of quadratic, or
fast/slow meaning smaller/larger magnitude of refractive index.
For warm plasma there will be other modes (e.g. Bernstein).  Haven't figured that out yet.

N.B. The plasma magnetic and species quantities come in through argument 'eq' which
is a derived type 'eq_point'
N.B. refractive index convention
nperp_sq = square of perpendicular component of nvec = n1**2 +n2**2
External procedures:
disp_solve_cold_nxsq_vs_nz in disp_solve_cold_nxsq_vs_nz.f90
solve_cold_nsq_vs_theta in solve_cold_nsq_vs_theta.f90

Description of module: eqdsk_magnetics_lin_interp_m

A simple  eqdsk equilibrium model. This code uses eqdsk routines in module eqdsk_utilities_m.f90
These were adapted from similar codes by Richard Fitzpatrick.  It uses Fitzpatrick's functions
for interpolating psi and its derivatives using simple 2 point or 3 point approximations.
In that regard they are not expected to be very accurate.  Is used just for comparison with
one that uses cubic splines for the interpolation -> eqdsk_magnetics_spline_interp

N.B. Values of Psi are shifted on initialization so that Psi is zero on axis.

Description of module: eqdsk_magnetics_spline_interp_m

A simple  eqdsk equilibrium model. This code uses eqdsk routines in module eqdsk_utilities_m.f90
These were adapted from similar codes by Richard Fitzpatrick.

N.B. Values of Psi are shifted on initialization so that Psi is zero on axis.
N.B  In eqdsk radial profiles (e.g. Q(psi) and RBphi(psi)) are given on a uniform grid
in poloidal flux.  It uses the same grid dimension as R -> NW.
For the splined profiles below the grid is PsiN -> [0,1]

Description of module: eqdsk_utilities_m

Routines for reading, writing, and interpolating geqdsk files.  These were adapted from
routines written by Richard Fitzpatrick,found in his EPEC github repo, and made into a
module.  Fitzpatrick's variable names are different from those found in Lang Lau's
description "G EQSDK FORMAT", 2/7/1997.  Most are obvious, but some are not completely:
Fitzpatrick's -> Lau's
T -> fpol == R*Btoroidal
P -> pres
TTp -> ffprim
Pp -> pprime

Fitzpatrick also provides some interpolation routines GetPsi, and derivatives that rely
on linear or 3 point interpolations on the R and Z grids.  I have adapted these routines
although I don't expect them to be as accurate as a cubic spline interpolation.  Note,
I expect the optimum values for dR, dZ to be 1/2 the grid spacing for first derivatives
and equal to the grid spacing for 2nd derivatives. so I have coded in spacing of 2*dR
for 2nd derivatives, and anticipate that the module initialization will set dR, dZ to
the grid spacing.

Description of module: equilibrium_m

Generic wrapper for various equilibrium routines.  Selects specific equilibrium model from
namelist /equilibrium_list/ equilib_model.

Description of module: file_input_ray_init_m

Generate the initial conditions for the rays
i.e. intitial position for each ray: rvec0(1:3, iray) and
information necessary to initialize k for each ray: kvec0(1:3, iray).
Also generates a power weight for each ray.
This routine initializes based on initial launch position (X,Y,Z) and initial
refractive indices (nx, ny, nz) from data in an input file.  Such data could represent
any kind of launching structure - beam, gril, current, strap ...  The (nx, ny, nz)
specify the ray initial direction, but don't have to constitute a unit vector, they
are normalized later
Not all input rays have to have valid dispersion solutions. For example if some initial
locations are outside the allowed domain (e.g. outside the plasma) or if some rays are
specified in a direction which is evanescent rather than propagating.  In that case
the ray is skipped (rather than crashing) and the total number of valid initializations
is taken for nray.
There is a complication with respect to the power weighting.  If the user inputs a power
weight distribution, but some don't initialize, the total weight will not sum to one. For
now the quick-and-dirty solution is to renormalize by n_rays_in/nray.  We also allow a
simple solution of uniform weight = 1/nray if all the weights are input as zero.

Description of module: mirror_magnetics_spline_interp_m

Calculates standard magnetic quantities for multiple magnetic mirrors aligned on the
z axis.  It reads a netCDF file containing Br,Bz, Aphi on an r,z grid and exports 2D
spline function derived types (Br_spline, Br_spline, Aphi_spline ).  The netCDF file is
written by stand-alone program mirror_magnetics.f90 which resides in mirror_magnetics_lib.

A flux-function-like quantity, Aphi, is provided to serve as a radial coordinate that is
constant along field lines.  This is normalized to be unity on the last un-interrupted
flux surface (or field line), LUFS.

N.B. This module uses the mirror_magnetics_m module in mirror_magnetics_lib to read the
netCDF file and gets the data for initialization from that module.

Description of module: multiple_mirror_eq_m


A general axisymmetric mirror equilibrium module that supports a choice of magnetics,
density, and temperature models.  It is assumed that there exists a flux function, Aphi,
Aphi = Axial magnetic flux inside radius r.  Presently densities and temperatures are
assumed constant on Aphi surfaces.  In the future axial variation of could be introduced.
An external magnetics module is required for each specific magnetics model,
which provides B, grad B tensor, and the flux function, Aphi. The magnetics model also
provides certain geometry data on initialization such as the r,z box dimensions on which
the equilibrium is defined, and the r,z position and Aphi at the limiter strike point of
the last un-interrupted flux surface, LUFS.

Input to multiple_mirror_eq() is rvec = (x,y,z) position
Outputs from multiple_mirror_eq() are all the quantities needed to fill an eq_point type.

Presently the only supported magnetics model is: mirror_magnetics_spline_interp
although someday may add an analytic form.

The radial coordinate for density and temperature profiles is AphiN = Aphi/Aphi_LUFS
which goes like r**2 near the axis.

Presently supported density models: 'constant', 'parabolic', 'density_spline_interp'
All species presently use the same density profile model.  Otherwise charge neutrality is
complicated.

Presently supported temperature models: 'zero' 'constant', 'parabolic',
and 'temperature_spline_interp'
Different species can have different profile models. Although presently only two different
spline profiles are supported: electron and ion.  All splined ion profiles are the same.

Note on boundaries:
Outermost boundary is defined by box_rmax, box_zmin, box_zmax.  These are in the
initialization for the specific magnetic model implementation (which for now is only
splines).  The init for mirror_magnetics_spline_interp_m sets these to zero, r_max,
z_min, z_max respectively, which are contained in the magnetic field netCDF file.

Plasma boundary is defined in terms of normalized Aphi on the last un-interrupted
flux surface, == Aphi_LUFS.


Description of module: ode_m

Contains parameters for initial value ODE solver.

Description of module: one_ray_init_XYZ_k_direction_m

This module initializes based on initial launch position (X,Y,Z) and initial
direction of wave vector (nX, nY, nZ))
The main purpose of the module is as a wrapper for the contained subroutine
ray_init_XYZ_k_direction(), which returns a refractive index vector, n_vec, that is
a solution of the dispersion relation in the direction of k evaluated at position (X,Y,Z).
The subroutine is used to initialize multiple rays inside some higher launcher model, such
as for a cone or beam.  The module also contains subroutine one_ray_init_XYZ_k_direction(),
which initializes a single ray from data in the namelist. This simple model could be
used for testing.

Description of module: openmp_m

Initializes the open mp setup, i.e. the number of threads.  There is no namelist data.
In this case the 'read_input' variable tells the init subroutine whether to set num_threads
to the minimum of (num_procs,nray) or to use the module variable num_threads which has been
set directly in a host program.  This make it possible to do scans of thread number scaling

Description of module: ray_init_m

Generates intitial position for each ray: rvec0(1:3, iray = 1:nray) and
initial refractive index vector for each ray: rindex_vec0(1:3, iray = 1:nray)

How the starting points for the rays are set depends on the plasma geometry e.g
slab, tokamak, mirror machine, ionosphere, etc and on the geometry of the antenna
There are several reasonable ways to initialize k values. In toroidal geometry at low
frequencies toroidal and poloidal mode numbers are meaningful.  At higher frequencies the
launch angle is more useful e.g. for ECH one launches a beam with a distribution of rays
around a central beam axis. Also initialization of k requires solution of the dispersion
relation, of which several different ones might be supported.  So initialization depends
geometry, antenna model, and dispersion model, at least.  These details are delegated to
more specialized ray_init modules, this subroutine merely serves as a selector for
those more specialized functions.  The dispersion solvers typically work with refractive
index rather than k, so these routines initialize refractive index.  These are converted
to k later.

So far the ray initialization models implemented are:
simple_slab_init, solovev, axisym_toroid_ray_init_R_Z_nphi_ntheta,
one_ray_init_XYZ_n_direction, file_input_ray_init

The action of the ray_init modules is to fill nray, rvec0(:,:) and rindex_vec0(:,:)

ray_pwr_wt(i) = fraction of total power carried by ray i.  Should provide a ray weight
subroutine as part of antenna model.  But for now al wights are just 1/nray.

This module is called from main program.

Description of module: ray_results_m

A module that contains results from ray tracing for storage in memory or for writing
at the end of the run.  The is a derived type 'run_results' that can accept the results
module data so we can have multiple instances (maybe useful for analysis). And there are
routines to write the data to files in either netCDF or list-directed ascii format.

N.B. ray_vec(:,:,:) is allocated ray_vec(nv, max_number_of_points, nray) where
max_number_of_points = nstep_max+1 to accomodate the initial point (step zero)
plus nstep_max steps beyond that.  Save for residual(max_number_of_points, nray)
and presumably the residual at step 0 is 0.

Note also that nstep_max may be much bigger than the actual number of steps taken by
any of the rays.  We typically set nstep_max large so we won't have to worry too much
about how big it is.  However when we write out the results to file there is no point in
keeping the superflous points.  So on output we just keep up to the largest value of
npoints(:).  Something to be alert to is that when data is read back in and put into the
module, max_number_of_points will equal 'actual_max_npoints' = the largest value of
npoints(:).

Description of module: rf_m


Description of module: RK4_ode_m

contains parameters specific to RK4_ode ODE solver.

Description of module: SG_ode_m

contains parameters specific to SG_ode ODE solver.

Description of module: simple_slab_ray_init_m

Contains data to initialize rays for a simple slab equilibrium (i.e. all variations are
in the x coordinate),
Contains a subroutine to do the initialization: simple_slab_ray_init,
which generates initial positions, rvec0 = (x0, 0., 0 : nray), and initial refractive
index vector, rindex_vec0 = (nx0, ny0, nz0 : nray).

ray_pwr_wt(i) = fraction of total power carried by ray i.  Should provide a ray weight
subroutine as part of antenna model.  But for now al weights are just 1/nray.

N.B. Some of the ray initializations may fail (e.g. initial point is outside plasma or
wave mode is evanescent).  This does not cause the program to stop.  It counts
the successful initializations and sets number of rays, nray, to that.

N.B. Since we don't know nray until the end, allocate temporary arrays rvec_temp,
rindex_vec_temp, ray_pwr_wt_temp then allocate the output arrays rvec0, rindex_vec0
at the end with proper length, nray!

External procedures:
solve_disp_nx_vs_ny_nz in solve_disp_nx_vs_ny_nz.f90

Description of module: slab_eq_m

Simple models for plasma stratified in x and uniform in y and z useful for testing and
benchmarking.  There are several different models for each quantity.
The coding is self explanatory, however some comments about the linear_2 models might be
useful.  For these one specifies the quantity at x = rmin and the slope there.  If any
of the models are linear_2, then to make the x ranges consistent, all the models should
be linear_2, zero, or constant.  The only complication is that in the subroutine
write_slab_profiles() rmaj now serves the role of max value of x for writing.  The
motivation for linear_2 is added flexibility in specifying the independent coordinate,
for example using the density or B field as a plotting axis coordinate.
N.B. There is danger of negative density or temperature in linear and Linear_2 models.
linear density or temp -> 1 + x/Ln_scale, asking for x < -Ln_scale will give < 0
Linear_2 density or temp -> n0 + dndx*(x - x0) so same issue

Description of module: solovev_eq_m

A simple Solovev equilibrium model based on notes from Cai-Ye Wang of 1995 and DBB 2/12/2022.

Description of module: solovev_magnetics_m

A simple Solovev equilibrium model based on notes from Cai-Ye Wang of 1995 and DBB 2/12/2022.

Description of module: solovev_ray_init_nphi_ntheta_m

Parameters to generate the initial conditions for the rays
i.e. intitial position for each ray: rvec0(1:3, iray) and
information necessary to initialize k for each ray: kvec0(1:3, iray)
Note: initialization of k requires solution of the dispersion relation
and depends on magnetic field and density information.  The actual
initialization of k occurs in subroutine 'initialize' which is called from
subroutine 'ray_tracing'.   Here the information necessary to do this
calculation (e.g. toroidal, poloidal mode number, toroidal, poloidal wave
number) is generated from data on the number of launch angles etc. and put
into rvec0, kvec0.  The values for rvec0, kvec0 are generated in the module
routines 'ray_init_...'
There are several reasonable ways to initialize k values,
particularly in toroidal geometry.  At low frequencies toroidal and poloidal mode
numbers are meaningful.  At higher frequencies the launch angle is more useful.
For ECH one launches a beam with a distribution of rays around a central beam axis.
The variable ray_init_model determines which of several k intialization schemes are used

Description of module: species_m

contains plasma species data.

Description of module: suscep_m

Contains routines to calculate susceptibility tensor, chi, for a single species and
dielectric tensor, eps. eps is of derived type dielectric_tensor.

N.B. is = species number (0:nspec), and eps = I + sum(chis(is))

There are 2 forms for dielectric tensor:
1) A general routine, dielectric_tensor, where the susceptibility model for each
species is selected by setting "spec_model" in module species_m to various values
e.g. "bessel" or "cold".  different suscep routines must be written for each spec_model
As of right now only "suscep_cold" is implemented.

2) A specific cold dielectric tensor where all species are cold

N.B. Plasma quantities come in from equilibrium_m.  An equilibrium routine must have been
called previously.
Routines:
suscep_cold(is)
suscep_bessel(is) -> To be implemented now in the spare parts box
dielectric_tensor
dielectric_cold

Description of module: temperature_spline_interp_m

Implements temperature profiles based on pointwise numeerical data contained in namelist
temperature_spline_interp_list.

Description of module: XY_curves_netCDF_m

Utilities to conveniently generate a netCDF file containing lists of X/Y vectors
suitable for plotting, therefore called curves.  It provides a derived type,
XY_curve_netCDF, containing the data needed for a single curve. It provides a subroutine,
write_XY_curves_netCDF, which accepts a list of type XY_curve_netCDF instances and writes
a netCDF file contining the curve data plus some metadata.
